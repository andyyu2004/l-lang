use super::ctx::{FrameCtx, GlobalCompilerCtx};
use super::{Constant, ConstantPool, Executable};
use crate::ast;
use crate::exec::{CodeBuilder, Function, Op};
use crate::ir::{self, DefId, LocalId};
use crate::tir;
use crate::ty::{Const, ConstKind, Ty, TyKind};
use crate::{lexer::symbol, typeck::TyCtx};
use ast::Lit;
use indexed_vec::{Idx, IndexVec};
use rustc_hash::FxHashMap;
use std::ops::{Deref, DerefMut};

crate struct Compiler<'tcx> {
    pub(super) frames: Vec<FrameCtx<'tcx>>,
    pub(super) gctx: &'tcx GlobalCompilerCtx<'tcx>,
}

impl<'tcx> Compiler<'tcx> {
    pub fn new(gctx: &'tcx GlobalCompilerCtx<'tcx>) -> Self {
        Self { frames: Default::default(), gctx }
    }

    pub fn compile(mut self, tir: &tir::Prog<'tcx>) -> Executable {
        tir.items.values().for_each(|item| self.gctx.assign_const_id(item.id.def));
        tir.items.values().for_each(|item| self.compile_item(item));
        match *self.gctx.main_fn.borrow() {
            Some(id) => {
                let constant_pool: ConstantPool =
                    self.gctx.constants.take().into_iter().map(|c| c.unwrap()).collect();
                Executable::with_main_index(constant_pool, id.index())
            }
            None => panic!("no main fn"),
        }
    }

    fn compile_item(&mut self, item: &tir::Item<'tcx>) {
        match &item.kind {
            tir::ItemKind::Fn(_, _, body) => {
                let f = self.compile_fn(body);
                self.gctx.set_const(item.id.def, Constant::Function(f));
                if item.ident.symbol == symbol::MAIN {
                    let const_id = self.gctx.def_id_to_const_id.borrow()[&item.id.def];
                    *self.gctx.main_fn.borrow_mut() = Some(const_id)
                }
            }
        }
    }

    /// pushes new `FrameCtx`
    pub(super) fn with_frame<R>(&mut self, f: impl FnOnce(&mut Compiler) -> R) -> R {
        self.frames.push(FrameCtx::new(self.gctx));
        let res = f(self);
        self.frames.pop();
        res
    }

    pub(super) fn mk_local(&mut self, id: ir::Id) {
        debug_assert!(self.locals.iter().all(|x| x.def == id.def));
        self.locals.push(id);
    }

    fn compile_fn(&mut self, body: &tir::Body<'tcx>) -> Function {
        self.with_frame(|compiler| {
            compiler.compile_body(body);
            compiler.finish()
        })
    }

    pub fn finish(&mut self) -> Function {
        self.emit_op(Op::ret);
        Function::new(self.build())
    }

    pub fn compile_body(&mut self, body: &tir::Body) {
        self.with_scope(|compiler| {
            body.params.iter().for_each(|p| compiler.compile_let_pat(p.pat));
            compiler.compile_expr(body.expr);
        });
    }

    /// emits unpatched jump and returns the index of the `jmp` instruction
    pub(super) fn emit_jmp(&mut self, jmp_op: Op) -> usize {
        let i = self.code_len();
        self.emit_op(jmp_op).emit16(u16::MAX);
        i
    }

    /// emits a `jmp` instruction that will jump over the code generated by `f`
    pub(super) fn with_jmp(&mut self, jmp_op: Op, f: impl FnOnce(&mut Self)) {
        let jmp_start = self.emit_jmp(jmp_op);
        f(self);
        let offset = (self.code_len() - jmp_start) as u16;
        self.patch_jmp(jmp_start, offset);
    }

    /// returns the `local_idx` for a variable with given `local_id`
    pub(super) fn resolve_local(&mut self, id: ir::Id) -> Option<u8> {
        Self::resolve_frame_local(self, id)
    }

    /// this relies on the observation that the `n`th local variable resides in
    /// slot `n` of the current frame
    pub(super) fn resolve_frame_local(frame: &FrameCtx, id: ir::Id) -> Option<u8> {
        frame.locals.iter().rposition(|&x| x == id).map(|i| i as u8)
    }

    /// creates a new lexical scope
    /// on exit, all variables declared in that scope will be popped
    pub(super) fn with_scope<R>(&mut self, f: impl FnOnce(&mut Self) -> R) -> R {
        let m = self.locals.len();
        let ret = f(self);
        let n = self.locals.len();
        assert!(n >= m);
        // `n - m` locals were declared in the scope of the new block
        // they need to be popped off at the end of the scope
        // we also need to take care to retain the value of the block (as blocks are exprs)
        // this is done with the novel `popscp` (pop_scope) instruction
        let p = n - m;
        // leave only the first `m` locals as the rest are now out of scope
        self.locals.truncate(m);
        // redundant if p == 0
        if p > 0 {
            self.emit_popscp(p as u8);
        }
        ret
    }

    /// emits pop instruction
    pub(super) fn pop(&mut self) {
        self.emit_op(Op::pop);
    }

    /// emits unit instruction
    pub(super) fn unit(&mut self) {
        self.emit_op(Op::unit);
    }
}

/// dereferences into its topmost frame
impl<'tcx> Deref for Compiler<'tcx> {
    type Target = FrameCtx<'tcx>;

    fn deref(&self) -> &Self::Target {
        self.frames.last().unwrap()
    }
}

impl<'tcx> DerefMut for Compiler<'tcx> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.frames.last_mut().unwrap()
    }
}
