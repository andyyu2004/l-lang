use super::{CompilerCtx, ConstantPool};
use crate::ast;
use crate::exec::{CodeBuilder, Function, Op};
use crate::ir::{self, DefId, LocalId};
use crate::tir;
use crate::ty::{Const, ConstKind, Ty, TyKind};
use crate::typeck::TyCtx;
use ast::Lit;
use indexed_vec::{Idx, IndexVec};
use rustc_hash::FxHashMap;
use std::ops::{Deref, DerefMut};

pub(super) struct Compiler<'tcx> {
    code: CodeBuilder,
    pub(super) locals: Vec<LocalId>,
    pub(super) ctx: &'tcx CompilerCtx<'tcx>,
}

impl<'tcx> Compiler<'tcx> {
    pub fn new(ctx: &'tcx CompilerCtx<'tcx>) -> Self {
        Self { ctx, code: Default::default(), locals: Default::default() }
    }

    pub fn finish(&mut self) -> Function {
        self.code.emit_op(Op::ret);
        Function::new(self.code.build())
    }

    pub fn compile_body(&mut self, body: &tir::Body) {
        self.with_scope(|compiler| {
            body.params.iter().for_each(|p| compiler.compile_let_pat(p.pat));
            compiler.compile_expr(body.expr);
        });
    }

    /// emits unpatched jump and returns the index of the `jmp` instruction
    pub(super) fn emit_jmp(&mut self, jmp_op: Op) -> usize {
        let i = self.code_len();
        self.emit_op(jmp_op).emit16(u16::MAX);
        i
    }

    /// emits a `jmp` instruction that will jump over the code generated by `f`
    pub(super) fn with_jmp(&mut self, jmp_op: Op, f: impl FnOnce(&mut Self)) {
        let jmp_start = self.emit_jmp(jmp_op);
        f(self);
        let offset = (self.code_len() - jmp_start) as u16;
        self.patch_jmp(jmp_start, offset);
    }

    /// returns the `local_idx` for a variable with given `local_id`
    pub(super) fn find_local_slot(&mut self, local_id: LocalId) -> u8 {
        self.locals.iter().rposition(|&id| id == local_id).unwrap() as u8
    }

    pub(super) fn with_scope<R>(&mut self, f: impl FnOnce(&mut Self) -> R) -> R {
        let m = self.locals.len();
        let ret = f(self);
        let n = self.locals.len();
        assert!(n >= m);
        // `n - m` locals were declared in the scope of the new block
        // they need to be popped off at the end of the scope
        // we also need to take care to retain the value of the block (as blocks are exprs)
        // this is done with the novel `popscp` (pop_scope) instruction
        let p = n - m;
        // leave only the first `m` locals as the rest are now out of scope
        self.locals.truncate(m);
        // redundant if p == 0
        if p > 0 {
            self.emit_popscp(p as u8);
        }
        ret
    }

    /// emits pop instruction
    pub(super) fn pop(&mut self) {
        self.emit_op(Op::pop);
    }

    /// emits unit instruction
    pub(super) fn unit(&mut self) {
        self.emit_op(Op::unit);
    }
}

impl<'tcx> Deref for Compiler<'tcx> {
    type Target = CodeBuilder;

    fn deref(&self) -> &Self::Target {
        &self.code
    }
}

impl<'tcx> DerefMut for Compiler<'tcx> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.code
    }
}
